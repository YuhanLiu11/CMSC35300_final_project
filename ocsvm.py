# -*- coding: utf-8 -*-
"""353 Project

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1er2MA4RVZLn8UCICinQeCGkHZf5NoTRB
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
import numpy as np
from scipy import linalg
import time
import matplotlib.pyplot as plt
import cvxopt

# todo: refactor

def make_blob_dataset(n_samples, contamination=0.05, random_state=42):
    rng = np.random.RandomState(random_state)
    X_inliers = 0.3 * rng.normal(size=(int(n_samples * (1. - contamination)), 2)) + 2
    X_outliers = rng.uniform(low=-1, high=5, size=(int(n_samples * contamination), 2))
    X = np.concatenate((X_inliers, X_outliers), axis=0)
    rng.shuffle(X)
    return X

X = make_blob_dataset(300)

def equation1_solver(K, nu=0.9):
  def preprocess():
    # P and q
    n = len(K) # todo
    P = K
    q = np.zeros(n)

    # G and h
    c = 1. / (nu * n)
    D = np.diag(np.ones(n) * -1)
    E = np.diag(np.ones(n))
    G = np.concatenate([D, E])
    h = np.concatenate([np.zeros(n), np.ones(n)*c])

    # A and b
    A = np.matrix(np.ones(n)) # todo
    b = 1.

    # return P, q, G, h, A, b as cvxopt objects
    return (cvxopt.matrix(P), cvxopt.matrix(q), 
            cvxopt.matrix(G), cvxopt.matrix(h), 
            cvxopt.matrix(A), cvxopt.matrix(b))

  # http://cvxopt.org/userguide/coneprog.html#cvxopt.solvers.qp
  cvxopt.solvers.options['show_progress'] = False
  solution = cvxopt.solvers.qp(*preprocess(), solver='mosec')
  alpha = np.ravel(solution['x'])
  support_idx = np.where(np.abs(alpha) > 1e-5)[0]
  support_alpha = alpha[support_idx]
  return support_alpha, support_idx

def rbf_kernel(X, gamma=.8):
  n = X.shape[0]
  K = np.empty((n, n))
  for i in range(n):
      for j in range(n):
          K[i, j] = np.exp(-gamma * linalg.norm(X[i] - X[j], 2)**2)
  return K



def train_ocsvm(X, gamma):
    K = rbf_kernel(X, gamma=gamma)
    alpha_support, idx_support = equation1_solver(K)
    b = alpha_support.dot(X[idx_support])

    print("num. of support vectors = ", idx_support.size)

    alpha_full = np.zeros((X.shape[0], 1))
    for i in range(len(idx_support)):
        alpha_full[idx_support[i], 0] = alpha_support[i]

    const_offset = np.sum((alpha_full@alpha_full.T)@K)
    radius = []
    for each in idx_support:
        radius.append(K[each, each] - 2 * alpha_full.T@K[each, : ] + const_offset)

    radius_mean = np.mean(radius)
    print(radius_mean, max(radius), min(radius))

    def calc_dist(r_sq, K, alpha, const_offset, idx):
        return np.sign(r_sq - const_offset + 2 * alpha_full.T@K[idx, : ] - K[idx, idx])

    # get the sign of each X
    signs = np.zeros(X.shape[0])
    for i in range(X.shape[0]):
        signs[i] = calc_dist(radius_mean, K, alpha_full, const_offset, i)
    print(signs)
    outlier_indices = []
    for i in range(len(signs)):
        if signs[i] < 0:
            print("outlier index: ", i)
            outlier_indices.append(i)
    colors = ['b' if s > 0 else 'r' for s in signs]
    return np.array(outlier_indices)
    # plt.scatter(X[:, 0], X[:, 1], color=colors)

